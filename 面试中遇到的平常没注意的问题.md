## 面试中遇到的平常没注意的问题
####1. for循环中let 声明的变量i  和 var 声明的变量i 有什么区别
 
* let 声明的是块级作用域；var 声明的是在全局范围内都有效
* let 声明的变量只在本轮循环有效；var 声明的全局范围有效，全局只有这一个i值，所以每次循环变量i的值都会发生改变

实例代码

```
 var a = []
 for （let i=0; i<10;i++）{
    a[i] = function(){
       console.log(i)
    }
 }
 
 console.log(a[6]())  // 6
 
 var a = []
 
 for (var i=0; i<10; i++) {
   a[i] = function() {
      console.log(i)
   }
 }
 
 console.log(a[6]()) // 10

```

for循环还有一个特别的地方， 就是设置循环变量的部分是一个父作用域，循环体内部是一个单独的子作用域
例

```
 for(let i = 0;i<3;i++){
   let i = 'abc'
   console.log(i)
 }
 // abc
 // abc
 // abc
```

#### 2.如何才能实现深复制(深拷贝)

##### 使用递归的方式进行深拷贝

 1 第一种递归方式，复制目标对象是函数参数
 
```
  // 深拷贝函数 复制目标对象
  function deepCopy(targetObject) {
       let newObj = {}
  		if(typeof targetObject !== 'object'){
  	        return obj
  		} else {
  			   for(let property in targetObject){
  		     newObj[property] = deepCopy(targetObject[property])
  		   }
  		}
  		return newObj
  }

```

 2 第二种递归方式，复制目标是对象自身

```
 // 使调用函数的自身对象被复制
 
 let deepCopy =()=>{
     let newObj = {}
     for(let property in this) {
        if(typof this[property] !== 'object') {
            newObj[property] = this[property]
        } else {
           newObj[property] =  this[property].deepCopy()
        }
     }
     return newObj
 }
 
 // 如果绑定在Object原生对象上，所有的对象都可以使用，但是注意，这里使用是让对象自身被复制
 
 Object.prototype.deepCopy = function() {
   let newObject = {}
   for(let property in this) {
     if(this[property] !== 'object'){
          newObject[property] = this[property]
     } else {
         newObject[property] = this[property].deepCopy()
     }
   }
   return newObject
 }
```
3  序列化反序列化 (一句代码搞定，装逼爽歪歪)

```
  let newObject = JSON.parse(JSON.stringify(targetObject))

```
                                                                                                 
                                                                                      